fastlane_require 'dotenv'

before_all do
    ensure_xcode_version
    Dotenv.load ".env.secret"
    ensure_git_status_clean
end

platform :ios do
    before_all do
        Dotenv.load ".env.ios"
    end

    desc "Builds and archives the app"
    lane :build do
        Dotenv.load ".env.ios.release"
        install_distribution_certificates
        build_app
    end

    desc "Runs test"
    lane :tests do
        Dotenv.load ".env.ios.dev"
        run_tests
    end

    desc "Deploy the app for a given flavour: alpha, beta, release"
    desc "Usage `bundle exec fastlane ios deploy --env ios.<specific env>`"
    lane :deploy do |options|
        install_distribution_certificates

        api_key = app_store_connect_api_key
        app_version = read_common_config(key: "APP_VERSION")
        build_number = latest_testflight_build_number(
            version: app_version,
            app_identifier: read_env_config(key: "PRODUCT_BUNDLE_IDENTIFIER"),
            initial_build_number: 0
        ) + 1
        
        increment_build_number(
            xcodeproj: ENV['PROJ_PATH'],
            build_number: build_number
        )

        build_app(
            include_symbols: true
        )

        upload_to_testflight(
            api_key: api_key
        )

        flavour = ENV['FLAVOUR']
        tag = "%s#%s-%s" % [app_version, build_number, flavour]
        add_git_tag(tag: tag)
        push_to_git_remote

        create_gh_release(flavour: flavour)
    end

    desc "Installs distribution certificates"
    desc "Usage `bundle exec fastlane ios install_distribution_certificate --env ios.<specific env>`"
    lane :install_distribution_certificates do
        code_signing(type: "appstore")
    end

    desc "Installs development certificates"
    lane :install_development_certificates do
        Dotenv.load ".env.ios.dev"
        code_signing(type: "development")
    end

    desc "Generate new dev certificates"
    lane :generate_new_dev_certificates do
        Dotenv.load ".env.ios.dev"
        code_signing(type: "development", readonly: false)
    end

    desc "Generate new appstore certificates"
    desc "Usage bundle exec fastlane ios generate_new_appstore_certificates --env ios.<specific env>"
    lane :generate_new_appstore_certificates do
        code_signing(type: "appstore", readonly: false)
    end

    desc "Registers a new iPhone device and updates the certificates"
    lane :register_new_iphone_device do
        register_new_device
        generate_new_dev_certificates
    end

end

platform :mac do
    before_all do
        Dotenv.load ".env.mac"
    end

    desc "Runs tests"
    lane :tests do
        run_tests
    end

    desc "Installs certificates on the machine"
    lane :install_development_certificates do
        code_signing(type: "development")
    end

    desc "Generates new certificates if needed"
    lane :generate_new_certificates do
        code_signing(type: "development", readonly: false)
    end

    desc "Registers a new mac device and updates the certificates"
    lane :register_new_mac_device do
        register_new_device
        generate_new_certificates
    end
end


def rev_changelog(flavour, most_recent_tags)
    git_commits_range_for_changelog = most_recent_tags.map { |tag| sh("git rev-list --abbrev-commit -n 1 #{tag}").strip }
    rev_changelog = changelog_from_git_commits(
      between: git_commits_range_for_changelog,
      pretty: "- %s"
    )
end


private_lane :create_gh_release do |options|
    flavour = options.fetch(:flavour).delete_prefix('"').delete_suffix('"') # if accidentally included
    
    ipaPath = lane_context[SharedValues::IPA_OUTPUT_PATH]
    dsymPath = lane_context[SharedValues::DSYM_OUTPUT_PATH]

    sh('git fetch --tags')
    most_recent_tags = sh("git tag | grep #{flavour} | sort -r | head -2").split("\n")

    changelog = rev_changelog(flavour, most_recent_tags)
    versions_string = dependencies_with_hyperlinks()

    release_description = "**Dependencies**: \n#{versions_string}\n\n**Changelog**: \n#{changelog}"
    last_tag = most_recent_tags[0]

    set_github_release(
        repository_name: ENV['REPO_NAME'],
        api_token: ENV['GIT_TOKEN'] ,
        name: last_tag,
        tag_name: last_tag,
        description: release_description,
        is_draft: true, # We mark all flavours as DRAFT and then promote them once approved by Apple.
        is_prerelease: flavour.include?("Beta"),
        upload_assets: [dsymPath, ipaPath]
    )
end

private_lane :dependencies_with_hyperlinks do |options|
    json_path = ENV['SWIFT_PACKAGE_RESOLVED_PATH']
    dependencies = read_json(
        json_path: json_path
    )[:pins]

    core_deps = [
        { :at => "swift-composable-architecture" },
        { :at => "swift-engine-toolkit" },
        { :at => "webrtc" },
        { :at => "k1" },
        { :at => "swift-atomics" },
        { :at => "asyncextensions" },
        { :at => "swift-algorithms" },
        { :at => "swift-async-algorithms" },
        { :at => "swift-dependencies-additions" },
        { :at => "swiftui-navigation" },
        { :at => "keychainaccess", :v_prefixed_tag => true },
    ]

    versions = Hash.new
    dependencies.each do |child_dict|
        child = child_dict[:identity]
        maybe_relevant_child = core_deps.detect { |h| 
            identity = h[:at]
            identity.include? child 
        }
        is_child_relevant = maybe_relevant_child.nil? == false
        if is_child_relevant
            child_state_dict = child_dict[:state]
            child_git_repo = child_dict[:location]
            if child_git_repo.end_with?(".git")
                child_git_repo = child_git_repo[0...-4] # remove ".git"
            end

            rev = child_state_dict[:revision]
            abbreviated_rev = rev[0, 7] # 7 first

            maybe_version = child_state_dict[:version]
            maybe_branch = child_state_dict[:branch]
            is_version_nil = maybe_version.nil?
            is_branch_nil = maybe_branch.nil?


            maybe_version_or_branch_string = !is_version_nil ? maybe_version : maybe_branch
            is_version_or_branch_nil = maybe_version_or_branch_string.nil?
            child_visible_string =  !is_version_or_branch_nil ? "#{maybe_version_or_branch_string} (#{abbreviated_rev})" : "commit (specified): #{rev}"
            child_link_commit = "#{child_git_repo}/commit/#{rev}"
            child_link_branch = "#{child_git_repo}/tree/#{maybe_branch}"

            should_prefix_tag_with__v = maybe_relevant_child[:v_prefixed_tag]
            tag = should_prefix_tag_with__v ? "v#{maybe_version}" : maybe_version
            child_link_version = "#{child_git_repo}/releases/tag/#{tag}"
            child_link = !is_version_nil ? child_link_version : (!is_branch_nil ? child_link_branch : child_link_commit)
            child_hyperlink = "[#{child_visible_string}](#{child_link})"
            versions[child] = child_hyperlink
        end
    end
    versions.map { |k, v| "- #{k}: #{v}" }.join("\n")
end

private_lane :register_new_device do |options|
    name = prompt(text: "Device name: ")
    udid = prompt(text: "Device UDID: ")
    devices = {}
    devices[name] = udid

    app_store_connect_api_key
    register_devices(devices: devices)
end

private_lane :read_common_config do |options|
    key = options.fetch(:key, "")
    get_xcconfig_value(
        path: ENV['COMMON_XCCONFIG_PATH'],
        name: key
    )
end

private_lane :read_env_config do |options|
    key = options.fetch(:key, "")
    get_xcconfig_value(
        path: ENV['XCCONFIG_PATH'],
        name: key
    )
end

private_lane :code_signing do |options|
    readonly = options.fetch(:readonly, true)
    type = options.fetch(:type, "development")

    if !readonly
        app_store_connect_api_key
    end

    create_keychain(
        unlock: false,
        timeout: 0
    )
    sync_code_signing(
        type: type,
        force_for_new_devices: true,
        readonly: readonly,
        app_identifier: read_env_config(key: "PRODUCT_BUNDLE_IDENTIFIER"),
        team_id: read_common_config(key: "DEV_TEAM")
    )
end
