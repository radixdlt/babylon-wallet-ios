//
// CommittedTransactionInfo.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

@available(*, deprecated, renamed: "GatewayAPI.CommittedTransactionInfo")
public typealias CommittedTransactionInfo = GatewayAPI.CommittedTransactionInfo

extension GatewayAPI {

public struct CommittedTransactionInfo: Codable, Hashable {

    public private(set) var stateVersion: Int64
    public private(set) var epoch: Int64
    public private(set) var round: Int64
    public private(set) var roundTimestamp: String
    public private(set) var transactionStatus: TransactionStatus
    /** Bech32m-encoded hash. */
    public private(set) var payloadHash: String?
    /** Bech32m-encoded hash. */
    public private(set) var intentHash: String?
    /** String-encoded decimal representing the amount of a related fungible resource. */
    public private(set) var feePaid: String?
    public private(set) var affectedGlobalEntities: [String]?
    public private(set) var confirmedAt: Date?
    public private(set) var errorMessage: String?
    /** Hex-encoded binary blob. */
    public private(set) var rawHex: String?
    public private(set) var receipt: TransactionReceipt?
    /** defined in core api specs. */
    public private(set) var message: AnyCodable?

    public init(stateVersion: Int64, epoch: Int64, round: Int64, roundTimestamp: String, transactionStatus: TransactionStatus, payloadHash: String? = nil, intentHash: String? = nil, feePaid: String? = nil, affectedGlobalEntities: [String]? = nil, confirmedAt: Date? = nil, errorMessage: String? = nil, rawHex: String? = nil, receipt: TransactionReceipt? = nil, message: AnyCodable? = nil) {
        self.stateVersion = stateVersion
        self.epoch = epoch
        self.round = round
        self.roundTimestamp = roundTimestamp
        self.transactionStatus = transactionStatus
        self.payloadHash = payloadHash
        self.intentHash = intentHash
        self.feePaid = feePaid
        self.affectedGlobalEntities = affectedGlobalEntities
        self.confirmedAt = confirmedAt
        self.errorMessage = errorMessage
        self.rawHex = rawHex
        self.receipt = receipt
        self.message = message
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case stateVersion = "state_version"
        case epoch
        case round
        case roundTimestamp = "round_timestamp"
        case transactionStatus = "transaction_status"
        case payloadHash = "payload_hash"
        case intentHash = "intent_hash"
        case feePaid = "fee_paid"
        case affectedGlobalEntities = "affected_global_entities"
        case confirmedAt = "confirmed_at"
        case errorMessage = "error_message"
        case rawHex = "raw_hex"
        case receipt
        case message
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(stateVersion, forKey: .stateVersion)
        try container.encode(epoch, forKey: .epoch)
        try container.encode(round, forKey: .round)
        try container.encode(roundTimestamp, forKey: .roundTimestamp)
        try container.encode(transactionStatus, forKey: .transactionStatus)
        try container.encodeIfPresent(payloadHash, forKey: .payloadHash)
        try container.encodeIfPresent(intentHash, forKey: .intentHash)
        try container.encodeIfPresent(feePaid, forKey: .feePaid)
        try container.encodeIfPresent(affectedGlobalEntities, forKey: .affectedGlobalEntities)
        try container.encodeIfPresent(confirmedAt, forKey: .confirmedAt)
        try container.encodeIfPresent(errorMessage, forKey: .errorMessage)
        try container.encodeIfPresent(rawHex, forKey: .rawHex)
        try container.encodeIfPresent(receipt, forKey: .receipt)
        try container.encodeIfPresent(message, forKey: .message)
    }
}

}
