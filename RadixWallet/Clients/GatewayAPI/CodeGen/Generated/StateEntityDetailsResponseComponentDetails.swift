//
// StateEntityDetailsResponseComponentDetails.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

@available(*, deprecated, renamed: "GatewayAPI.StateEntityDetailsResponseComponentDetails")
typealias StateEntityDetailsResponseComponentDetails = GatewayAPI.StateEntityDetailsResponseComponentDetails

extension GatewayAPI {

struct StateEntityDetailsResponseComponentDetails: Codable, Hashable {

    private(set) var type: StateEntityDetailsResponseItemDetailsType
    /** Bech32m-encoded human readable version of the address. */
    private(set) var packageAddress: String?
    private(set) var blueprintName: String
    private(set) var blueprintVersion: String
    /** A representation of a component's inner state. If this entity is a `GenericComponent`, this field will be in a programmatic JSON structure (you can deserialize it as a `ProgrammaticScryptoSborValue`). Otherwise, for \"native\" components such as `Account`, `Validator`, `AccessController`, `OneResourcePool`, `TwoResourcePool`, and `MultiResourcePool`, this field will be a custom JSON model defined in the Core API schema.  */
    private(set) var state: AnyCodable?
    private(set) var roleAssignments: ComponentEntityRoleAssignments?
    /** String-encoded decimal representing the amount of a related fungible resource. */
    private(set) var royaltyVaultBalance: String?
    private(set) var royaltyConfig: ComponentRoyaltyConfig?
    /** Bech32m-encoded human readable version of the address. */
    private(set) var twoWayLinkedDappAddress: String?
    private(set) var twoWayLinkedDappDetails: TwoWayLinkedDappOnLedgerDetails?
    private(set) var nativeResourceDetails: NativeResourceDetails?

    init(type: StateEntityDetailsResponseItemDetailsType, packageAddress: String? = nil, blueprintName: String, blueprintVersion: String, state: AnyCodable? = nil, roleAssignments: ComponentEntityRoleAssignments? = nil, royaltyVaultBalance: String? = nil, royaltyConfig: ComponentRoyaltyConfig? = nil, twoWayLinkedDappAddress: String? = nil, twoWayLinkedDappDetails: TwoWayLinkedDappOnLedgerDetails? = nil, nativeResourceDetails: NativeResourceDetails? = nil) {
        self.type = type
        self.packageAddress = packageAddress
        self.blueprintName = blueprintName
        self.blueprintVersion = blueprintVersion
        self.state = state
        self.roleAssignments = roleAssignments
        self.royaltyVaultBalance = royaltyVaultBalance
        self.royaltyConfig = royaltyConfig
        self.twoWayLinkedDappAddress = twoWayLinkedDappAddress
        self.twoWayLinkedDappDetails = twoWayLinkedDappDetails
        self.nativeResourceDetails = nativeResourceDetails
    }

    enum CodingKeys: String, CodingKey, CaseIterable {
        case type
        case packageAddress = "package_address"
        case blueprintName = "blueprint_name"
        case blueprintVersion = "blueprint_version"
        case state
        case roleAssignments = "role_assignments"
        case royaltyVaultBalance = "royalty_vault_balance"
        case royaltyConfig = "royalty_config"
        case twoWayLinkedDappAddress = "two_way_linked_dapp_address"
        case twoWayLinkedDappDetails = "two_way_linked_dapp_details"
        case nativeResourceDetails = "native_resource_details"
    }

    // Encodable protocol methods

    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(type, forKey: .type)
        try container.encodeIfPresent(packageAddress, forKey: .packageAddress)
        try container.encode(blueprintName, forKey: .blueprintName)
        try container.encode(blueprintVersion, forKey: .blueprintVersion)
        try container.encodeIfPresent(state, forKey: .state)
        try container.encodeIfPresent(roleAssignments, forKey: .roleAssignments)
        try container.encodeIfPresent(royaltyVaultBalance, forKey: .royaltyVaultBalance)
        try container.encodeIfPresent(royaltyConfig, forKey: .royaltyConfig)
        try container.encodeIfPresent(twoWayLinkedDappAddress, forKey: .twoWayLinkedDappAddress)
        try container.encodeIfPresent(twoWayLinkedDappDetails, forKey: .twoWayLinkedDappDetails)
        try container.encodeIfPresent(nativeResourceDetails, forKey: .nativeResourceDetails)
    }
}

}
